/*0=======================================================0
  |  Title:    Linux Dice Driver                          |
  |  Author:   Brandon S. Hang                            |
  |  Version:  1.500                                      |
  |  Class:    CS 0449                                    |
  |            Project 4                                  |
  |            April 10, 2016                             |
  |                                                       |
  |  This program builds a character device that          |
  |  simulates rolls of a 6-sided die.  It is intended    |
  |  to be used as a driver for yahtzee.c, a Yahtzee      |
  |  simulator.                                           |
  |                                                       |
  |  When compiling this driver, please ensure that it    |
  |  is compiled in 32-bit mode.                          |
  |                                                       |
  |  Compilation with the Makefile: make ARCH=i386        |
  0=======================================================0*/

#include <linux/fs.h>
#include <linux/init.h>
#include <linux/miscdevice.h>
#include <linux/module.h>
#include <linux/random.h>
#include <asm/uaccess.h>

unsigned char get_random_byte(int max);				// Prototype for the single random byte helper function


/*
 * This function is executed when a process calls read() on /dev/dice
 */
static ssize_t dice_read(struct file *file, char *dice_buffer,
		size_t count, loff_t *ppos) {
	
	char kern_buffer[count];				// Holds a kernel array of randomly generated bytes
	int i = 0;
	
	if (0 == count) {				// Returns if the count is zero
		return 0;
	}
	
	for (i = 0; i < count; i++) {					// Fills the kernel array with random single bytes
		kern_buffer[i] = get_random_byte(6) + 1;
	}
	
	if (copy_to_user(dice_buffer, kern_buffer, count)) {	// Returns a negative error value if kernel-to-program-space transfer fails
		return -EINVAL;
	}
	
	*ppos += count;				// Updates the offset provided by the program
	
	return *ppos;			// Returns the offset pointer
}


/*
 * Defines a file operations struct that describes what actions to take during file access
 */
static const struct file_operations dice_fops = {
	
	.owner = THIS_MODULE,
	.read = dice_read,				// Describes the file read action
};


/*
 * Defines a struct needed to register the driver as a miscellaneous device
 */
static struct miscdevice dice_driver = {
	
	MISC_DYNAMIC_MINOR, "dice", &dice_fops		// Dynamically assigns a minor number and names the device "/dev/dice"
};


/*
 * Registers the device using the module's initialization function
 */
static int __init dice_init(void) {
	
	int status = misc_register(&dice_driver);		// Creates the dice driver under /sys/class/misc
	
	if (status) {
		printk(KERN_ERR "Unable to register dice driver as a misc device :(\n");
	}
	
	return status;
}


/*
 * Unregisters the device using the module's exit function
 */
static void __exit dice_exit(void) {
	
	misc_deregister(&dice_driver);
}


/*
 * Helper function that returns a single, unsigned, random byte
 */
unsigned char get_random_byte(int max) {
	
	unsigned char ch;
	
	get_random_bytes(&ch, 1);
	return ch % max;
}


/*
 * Module initialization and exit macros
 */
module_init(dice_init);
module_exit(dice_exit);


/*
 * Module information
 */
MODULE_LICENSE("GPL");					// Not tainted!
MODULE_AUTHOR("Brandon S. Hang");
MODULE_DESCRIPTION("They see me rollin' (dice).  They hatin'.");
MODULE_VERSION("1.500");

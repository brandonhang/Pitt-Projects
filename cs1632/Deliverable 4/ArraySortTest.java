/**
 * @author Brandon S. Hang
 * @version 1.100
 * CS 1632
 * Deliverable 4
 * March 24, 2016
 */

import static org.junit.Assert.*;

import org.junit.Test;
import org.junit.BeforeClass;

import java.util.Arrays;
import java.util.LinkedList;
import java.util.Random;

public class ArraySortTest {
	
	private static Random randomNumGen = new Random();
	private static int[][] randomArray;		// Holds a set of randomly sized and filled arrays
	private static int[][] sortedArray;		// Holds the set of arrays after sorting
	private static final int NUMTESTS = 150;		// Declares the number of arrays to test
	private static final int MAXSIZE = 200;			// Defines the maximum size an array can be
	private static final int INTRANGE = 276068;		// The integer will range from (negative this number) to (positive this number - 1)
	
	
	/**
	 * This method generates a set of randomly sized arrays and fills them.  It also sorts the arrays but stores
	 * it as a different set.  The number of arrays and their maximum size is defined in the file-scope
	 * variables found above.  The integer range of each number in the array was achieved through slamming my
	 * fingers on the numpad and using the number generated by the action.  Each of these fields can be modified
	 * by the tester.
	 */
	@BeforeClass
	public static void initializeArrays() {
		
		randomArray = new int[NUMTESTS][];
		sortedArray = new int[NUMTESTS][];
		
		for (int i = 0; i < NUMTESTS; i++) {
			int randomSize = randomNumGen.nextInt(MAXSIZE) + 1;		// Generates a random array size from 1 to the maximum size
			randomArray[i] = new int[randomSize];
			
			for (int j = 0; j < randomSize; j++) {
				randomArray[i][j] = randomNumGen.nextInt(INTRANGE * 2) - INTRANGE;		// Generates a random integer from the integer range
			}
			sortedArray[i] = Arrays.copyOf(randomArray[i], randomArray[i].length);			// Copies and sorts the randomly generated array
			Arrays.sort(sortedArray[i]);			// Stores a sorted array
		}
	}
	
	
	/**
	 * Tests that the sorted and unsorted arrays are of the same size.
	 */
	@Test
	public void testSameSize() {
		
		for (int i = 0; i < NUMTESTS; i++) {
			assertEquals(randomArray[i].length, sortedArray[i].length);
		}
	}
	
	
	/**
	 * Tests that integers in the sorted array are always increasing in or
	 * staying the same value.  Coincidentally, this also tests that
	 * integers in the sorted array are never decreasing.
	 */
	@Test
	public void testAscendingOrder() {
		
		for (int i = 0; i < NUMTESTS; i++) {
			for (int j = 0; j < sortedArray[i].length - 1; j++) {			// Iterates through each the entirety of each array
				if (sortedArray[i].length == 1) {
					assertTrue(true);				// A 1 element array is always sorted
					break;
				}
				else {
					assertTrue(sortedArray[i][j + 1] >= sortedArray[i][j]);
				}
			}
		}
	}
	
	
	/**
	 * Tests that every integer in the unsorted array is in the sorted
	 * array.  Coincidentally, this also tests that no element in the
	 * unsorted array is in the sorted array.
	 */
	@Test
	public void testSameContents() {
		
		for (int i = 0; i < NUMTESTS; i++) {
			LinkedList<Integer> unsortedList = new LinkedList<Integer>();		// Linked lists are used to make testing for "sameness" easier
			LinkedList<Integer> sortedList = new LinkedList<Integer>();
			
			if (sortedArray[i].length != randomArray[i].length) {			// If the unsorted and sorted arrays are of unequal length, the test fails immediately
				fail();
			}
			else {
				for (int j = 0; j < sortedArray[i].length; j++) {		// Converts arrays into linked lists
					sortedList.add(sortedArray[i][j]);
					unsortedList.add(randomArray[i][j]);
				}
				
				for (int j = 0; j < randomArray[i].length; j++) {
					Integer number = unsortedList.pop();				// Pops (like a stack) an integer off of the unsorted linked list
					assertTrue(sortedList.remove(number));				// Searches for and removes the popped integer from the sorted linked list
				}
				assertEquals(sortedList.size(), unsortedList.size());
			}
		}
	}
	
	
	/**
	 * Tests that the sorting function is idempotent; sorting the
	 * already sorted array yields identical arrays.
	 */
	@Test
	public void testIdempotence() {
		
		for (int i = 0; i < NUMTESTS; i++) {
			int[] idempotentArray = Arrays.copyOf(sortedArray[i], sortedArray[i].length);		// Copies and sorts an already sorted array
			Arrays.sort(idempotentArray);
			assertArrayEquals(idempotentArray, sortedArray[i]);
		}
	}
	
	
	/**
	 * Tests that the sorting function is pure; sorting the same
	 * unsorted array twice yields two identically sorted arrays.
	 */
	@Test
	public void testPurity() {
		
		for (int i = 0; i < NUMTESTS; i++) {
			int[] pureArray = Arrays.copyOf(randomArray[i], randomArray[i].length);			// Copies and sorts an unsorted array
			Arrays.sort(pureArray);
			assertArrayEquals(pureArray, sortedArray[i]);
		}
	}
}
